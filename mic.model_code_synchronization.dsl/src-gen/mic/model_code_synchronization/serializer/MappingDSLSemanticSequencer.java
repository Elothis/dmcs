/*
 * generated by Xtext 2.18.0
 */
package mic.model_code_synchronization.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mic.model_code_synchronization.mappingDSL.Codestructure;
import mic.model_code_synchronization.mappingDSL.Condition;
import mic.model_code_synchronization.mappingDSL.IntegrationMechanismDeclaration;
import mic.model_code_synchronization.mappingDSL.Mapping;
import mic.model_code_synchronization.mappingDSL.MappingDSLPackage;
import mic.model_code_synchronization.mappingDSL.Model;
import mic.model_code_synchronization.mappingDSL.ModelElement;
import mic.model_code_synchronization.services.MappingDSLGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MappingDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MappingDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MappingDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MappingDSLPackage.CODESTRUCTURE:
				sequence_Codestructure(context, (Codestructure) semanticObject); 
				return; 
			case MappingDSLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MappingDSLPackage.INTEGRATION_MECHANISM_DECLARATION:
				sequence_IntegrationMechanismDeclaration(context, (IntegrationMechanismDeclaration) semanticObject); 
				return; 
			case MappingDSLPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case MappingDSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MappingDSLPackage.MODEL_ELEMENT:
				sequence_ModelElement(context, (ModelElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Codestructure returns Codestructure
	 *
	 * Constraint:
	 *     codestructure=CodeStructureType
	 */
	protected void sequence_Codestructure(ISerializationContext context, Codestructure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingDSLPackage.Literals.CODESTRUCTURE__CODESTRUCTURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingDSLPackage.Literals.CODESTRUCTURE__CODESTRUCTURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCodestructureAccess().getCodestructureCodeStructureTypeEnumRuleCall_2_0(), semanticObject.getCodestructure());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     condition=STRING
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingDSLPackage.Literals.CONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingDSLPackage.Literals.CONDITION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getConditionSTRINGTerminalRuleCall_2_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns IntegrationMechanismDeclaration
	 *     IntegrationMechanismDeclaration returns IntegrationMechanismDeclaration
	 *
	 * Constraint:
	 *     ((name=ID codestructure=Codestructure) | modelelement=ModelElement | condition=Condition | mapping=Mapping)+
	 */
	protected void sequence_IntegrationMechanismDeclaration(ISerializationContext context, IntegrationMechanismDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     mapping=STRING
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingDSLPackage.Literals.MAPPING__MAPPING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingDSLPackage.Literals.MAPPING__MAPPING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingAccess().getMappingSTRINGTerminalRuleCall_2_0(), semanticObject.getMapping());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ModelElement
	 *
	 * Constraint:
	 *     modelelement=ModelElementType
	 */
	protected void sequence_ModelElement(ISerializationContext context, ModelElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingDSLPackage.Literals.MODEL_ELEMENT__MODELELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingDSLPackage.Literals.MODEL_ELEMENT__MODELELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelElementAccess().getModelelementModelElementTypeEnumRuleCall_2_0(), semanticObject.getModelelement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
